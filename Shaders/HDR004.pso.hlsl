//
// Generated by Microsoft (R) D3DX9 Shader Compiler 9.08.299.0000
//
//   vsa shaderdump19/HDR004.pso /Fcshaderdump19/HDR004.pso.dis
//
//
// Parameters:
//
float4 HDRParam : register(c1);
float4 TESR_ToneMapping : register(c19);

sampler2D ScreenSpace : register(s0);
sampler2D DestBlend : register(s1);
sampler2D AvgLum : register(s2);

//
// Registers:
//
//   Name         Reg   Size
//   ------------ ----- ----
//   HDRParam     const_1       1
//   ScreenSpace         texture_0       1
//   DestBlend    texture_1       1
//   AvgLum       texture_2       1
//

#include "Includes/Color.hlsl"

// Structures:

struct VS_OUTPUT {
    float2 ScreenOffset : TEXCOORD0;
    float2 texcoord_1 : TEXCOORD1;
};

struct PS_OUTPUT {
    float4 color_0 : COLOR0;
};

// Code:

float to_luma(float3 color) {
	return dot(color, float3(0.299, 0.587, 0.114));
}

float3 tonemap_aces(float3 color, float3 white) {
    static const float A = 0.0245786;
	static const float B = 0.000090537;
	static const float C = 0.983729;
	static const float D = 0.4329510;
	static const float E = 0.238081;

    color = (color * (color + A) - B) / (color * (C * color + D) + E);
    white = (white * (white + A) - B) / (white * (C * white + D) + E);
    return saturate(color / white);
}

float2 get_resolution() {
    float width = trunc(TESR_ToneMapping.x);
    float height = (TESR_ToneMapping.x - width) * 10000;
    return float2(width, height);
}

float4 main(float2 uv: TEXCOORD1, float2 bloom_uv: TEXCOORD0): COLOR0 {
    // Some game objects (specially darker skin colors) go to negative values,
    // so we need to clip that before tonemapping.
    float4 color = max(tex2D(DestBlend, uv), 0);

    float2 res = get_resolution();
    bloom_uv.y *= res.y / res.x;

    float4 bloom = tex2D(ScreenSpace, bloom_uv);

    color = lerp(color, bloom, TESR_ToneMapping.y);

    float adapt = to_luma(tex2D(AvgLum, uv).rgb);
    color /= clamp(adapt * 1.5, 0.5, 2.0);

    color.rgb = tonemap_aces(color.rgb, GetWhitePoint());

    return color;
}

PS_OUTPUT _main(VS_OUTPUT IN) {
    PS_OUTPUT OUT;

#define	weight(v)		dot(v, 1)

    float3 reslt;
    float3 color;
    float3 avlum;
    float3 blurc;
    float rwhite;
    float whitef;
    float luma, lumc, amplify;

    blurc = tex2D(ScreenSpace, IN.ScreenOffset.xy).rgb;
    color = tex2D(DestBlend, IN.texcoord_1.xy).rgb;
    avlum = tex2D(AvgLum, IN.ScreenOffset.xy).rgb;

    avlum = max(0.05, avlum);
	luma = GetLuminance(avlum);
    whitef = HDRParam.x / max(luma, HDRParam.x);
    blurc = blurc * (whitef * GetWhitePoint() * TESR_ToneMapping.y);
    color = color * (whitef * GetWhitePoint() * TESR_ToneMapping.z);
    reslt = blurc + color;

    luma = GetLuminance(avlum);
    lumc = GetLuminance(reslt);
    amplify = log(2.2 + 4.2 * luma + TESR_ToneMapping.x + min(lumc * 64.0, (0.001 / pow(luma, 2.2)))) / log(2.2 + 4.2 * luma + TESR_ToneMapping.x + lumc);
    reslt *= amplify;

    luma = GetLuminance(avlum);
    lumc = GetLuminance(reslt);
    reslt = lerp(lerp(BlueShift / 32, reslt * BlueShift / length(BlueShift), saturate(sqrt(luma) * 2)), reslt, saturate(sqrt(lumc) * 2));

    OUT.color_0.a = 1;
    OUT.color_0.rgb = reslt;

    return OUT;
};

// approximately 13 instruction slots used (3 texture, 10 arithmetic)
